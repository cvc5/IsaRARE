;;;;;;;;;;;;;;;;;
;; Arith
;;;;;;;;;;;;;;;;;

(declare-rule arith-div-total-zero-real ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (/_total t1 0/1) 0/1)
)
(declare-rule arith-div-total-zero-int ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (/_total t1 0) 0/1)
)
(declare-rule arith-elim-gt ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (> t1 s1) (not (>= s1 t1)))
)
(declare-rule arith-elim-lt ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (< t1 s1) (not (>= t1 s1)))
)
(declare-rule arith-elim-leq ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (<= t1 s1) (>= s1 t1))
)
(declare-rule arith-abs-eq ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (= (abs x1) (abs y1)) (or (= x1 y1) (= x1 (- y1))))
)
(declare-rule arith-geq-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (>= (ite C1 t1 s1) r1) (ite C1 (>= t1 r1) (>= s1 r1)))
)
(declare-rule arith-leq-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (<= (ite C1 t1 s1) r1) (ite C1 (<= t1 r1) (<= s1 r1)))
)
(declare-rule arith-min-lt1 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (<= (ite (< t1 s1) t1 s1) t1) true)
)
(declare-rule arith-min-lt2 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (<= (ite (< t1 s1) t1 s1) s1) true)
)
(declare-rule arith-max-geq1 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (>= (ite (>= t1 s1) t1 s1) t1) true)
)
(declare-rule arith-max-geq2 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (>= (ite (>= t1 s1) t1 s1) s1) true)
)

;;;;;;;;;;;;;;;;;
;; Ite
;;;;;;;;;;;;;;;;;

(declare-rule ite-true-cond ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (ite true x1 y1) x1)
)
(declare-rule ite-false-cond ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x1 y1)
  :conclusion (= (ite false x1 y1) y1)
)
(declare-rule ite-not-cond ((@T0 Type) (@T1 Type) (c1 Bool) (x1 @T0) (y1 @T1))
  :args (c1 x1 y1)
  :conclusion (= (ite (not c1) x1 y1) (ite c1 y1 x1))
)
(declare-rule ite-eq-branch ((@T0 Type) (c1 Bool) (x1 @T0))
  :args (c1 x1)
  :conclusion (= (ite c1 x1 x1) x1)
)
(declare-rule ite-then-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 (ite c1 x1 y1) z1) (ite c1 x1 z1))
)
(declare-rule ite-else-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 x1 (ite c1 y1 z1)) (ite c1 x1 z1))
)
(declare-rule ite-then-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 (ite (not c1) x1 y1) z1) (ite c1 y1 z1))
)
(declare-rule ite-else-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c1 x1 y1 z1)
  :conclusion (= (ite c1 x1 (ite (not c1) y1 z1)) (ite c1 x1 y1))
)

;;;;;;;;;;;;;;;;;
;; Equality
;;;;;;;;;;;;;;;;;

(declare-rule eq-refl ((@T0 Type) (t1 @T0))
  :args (t1)
  :conclusion (= (= t1 t1) true)
)
(declare-rule eq-symm ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (= t1 s1) (= s1 t1))
)
(declare-rule eq-cond-deq ((@T0 Type) (@T1 Type) (@T2 Type) (t1 @T0) (s1 @T1) (r1 @T2))
  :premises ((= (= s1 r1) false))
  :args (t1 s1 r1)
  :conclusion (= (= (= t1 s1) (= t1 r1)) (and (not (= t1 s1)) (not (= t1 r1))))
)
(declare-rule eq-ite-lift ((@T0 Type) (@T1 Type) (@T2 Type) (C1 Bool) (t1 @T0) (s1 @T1) (r1 @T2))
  :args (C1 t1 s1 r1)
  :conclusion (= (= (ite C1 t1 s1) r1) (ite C1 (= t1 r1) (= s1 r1)))
)

;;;;;;;;;;;;;;;;;
;; Distinct
;;;;;;;;;;;;;;;;;

(declare-rule distinct-binary-elim ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1 s1)
  :conclusion (= (distinct t1 s1) (not (= t1 s1)))
)
