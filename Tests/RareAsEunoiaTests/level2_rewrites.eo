;;;;;;;;;;;;;;;;;
;; Arith
;;;;;;;;;;;;;;;;;

(declare-rule arith-mod-over-mod ((c1 Int) (ts1 Int :list) (r1 Int) (ss1 Int :list))
  :premises ((= (= c1 0) false))
  :args (c1 ts1 r1 ss1)
  :conclusion (= (mod_total (+ ts1 (mod_total r1 c1) ss1) c1) (mod_total (+ ts1 r1 ss1) c1))
)

;;;;;;;;;;;;;;;;;
;; Boolean
;;;;;;;;;;;;;;;;;

(declare-rule bool-and-conf ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (and xs1 w1 ys1 (not w1) zs1) false)
)
(declare-rule bool-and-conf2 ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (and xs1 (not w1) ys1 w1 zs1) false)
)
(declare-rule bool-or-taut ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (or xs1 w1 ys1 (not w1) zs1) true)
)
(declare-rule bool-or-taut2 ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs1 w1 ys1 zs1)
  :conclusion (= (or xs1 (not w1) ys1 w1 zs1) true)
)
(declare-rule bool-or-de-morgan ((x1 Bool) (y1 Bool) (zs1 Bool :list))
  :args (x1 y1 zs1)
  :conclusion (= (not (or x1 y1 zs1)) (and (not x1) (not (or y1 zs1))))
)

(declare-rule bool-and-de-morgan ((x1 Bool) (y1 Bool) (zs1 Bool :list))
  :args (x1 y1 zs1)
  :conclusion (= (not (and x1 y1 zs1)) (or (not x1) (not (and y1 zs1))))
)
(declare-rule bool-or-and-distrib ((y1 Bool) (y2 Bool) (ys1 Bool :list) (z1 Bool) (zs1 Bool :list))
  :args (y1 y2 ys1 z1 zs1)
  :conclusion (= (or (and y1 y2 ys1) z1 zs1) (and (or y1 z1 zs1) (or (and y2 ys1) z1 zs1)))
)
(declare-rule bool-implies-or-distrib ((y1 Bool) (y2 Bool) (ys1 Bool :list) (z1 Bool))
  :args (y1 y2 ys1 z1)
  :conclusion (= (=> (or y1 y2 ys1) z1) (and (=> y1 z1) (=> (or y2 ys1) z1)))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Strings and regular expressions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare-rule str-to-lower-concat ((s1 String) (s2 String) (s3 String :list))
  :args (s1 s2 s3)
  :conclusion (= (str.to_lower (str.++ s1 s2 s3)) (str.++ (str.to_lower s1) (str.to_lower (str.++ s2 s3))))
)
(declare-rule str-to-upper-concat ((s1 String) (s2 String) (s3 String :list))
  :args (s1 s2 s3)
  :conclusion (= (str.to_upper (str.++ s1 s2 s3)) (str.++ (str.to_upper s1) (str.to_upper (str.++ s2 s3))))
)

(declare-rule str-to-int-concat-neg-one ((s1 String :list) (s2 String) (s3 String :list))
  :premises ((= (str.to_int s2) -1))
  :args (s1 s2 s3)
  :conclusion (= (str.to_int (str.++ s1 s2 s3)) -1)
)
(declare-rule str-leq-concat-false ((s1 String :list) (t1 String) (s2 String) (t2 String :list) (s3 String :list))
  :premises ((= (str.len t1) (str.len s2)) (= (str.<= t1 s2) false))
  :args (s1 t1 s2 t2 s3)
  :conclusion (= (str.<= (str.++ s1 t1 t2) (str.++ s1 s2 s3)) false)
)
(declare-rule str-leq-concat-true ((s1 String :list) (t1 String) (s2 String) (t2 String :list) (s3 String :list))
  :premises ((= (str.len t1) (str.len s2)) (= (= t1 s2) false) (= (str.<= t1 s2) true))
  :args (s1 t1 s2 t2 s3)
  :conclusion (= (str.<= (str.++ s1 t1 t2) (str.++ s1 s2 s3)) true)
)
(declare-rule str-leq-concat-base-1 ((t1 String) (t2 String :list) (s1 String))
  :premises ((= (str.len t1) (str.len s1)) (= (= t1 s1) false))
  :args (t1 t2 s1)
  :conclusion (= (str.<= (str.++ t1 t2) s1) (str.<= t1 s1))
)
(declare-rule str-leq-concat-base-2 ((t1 String) (s1 String) (s2 String :list))
  :premises ((= (str.len t1) (str.len s1)) (= (= t1 s1) false))
  :args (t1 s1 s2)
  :conclusion (= (str.<= t1 (str.++ s1 s2)) (str.<= t1 s1))
)

(declare-rule re-concat-star-swap ((xs1 RegLan :list) (r1 RegLan) (ys1 RegLan :list))
  :args (xs1 r1 ys1)
  :conclusion (= (re.++ xs1 (re.* r1) r1 ys1) (re.++ xs1 r1 (re.* r1) ys1))
)

(declare-rule re-concat-star-subsume1 ((xs1 RegLan :list) (r1 RegLan) (ys1 RegLan :list))
  :args (xs1 r1 ys1)
  :conclusion (= (re.++ xs1 (re.* r1) (re.* re.allchar) ys1) (re.++ xs1 (re.* re.allchar) ys1))
)
(declare-rule re-concat-star-subsume2 ((xs1 RegLan :list) (r1 RegLan) (ys1 RegLan :list))
  :args (xs1 r1 ys1)
  :conclusion (= (re.++ xs1 (re.* re.allchar) (re.* r1) ys1) (re.++ xs1 (re.* re.allchar) ys1)))
(declare-rule re-concat-merge ((xs1 RegLan :list) (s1 String) (t1 String) (ys1 RegLan :list))
  :args (xs1 s1 t1 ys1)
  :conclusion (= (re.++ xs1 (str.to_re s1) (str.to_re t1) ys1) (re.++ xs1 (str.to_re (str.++ s1 t1) ys1)))
)
(declare-rule re-union-all ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1 ys1)
  :conclusion (= (re.union xs1 (re.* re.allchar) ys1) (re.* re.allchar))
)

(declare-rule re-inter-all ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1 ys1)
  :conclusion (= (re.inter xs1 (re.* re.allchar) ys1) (re.inter xs1 ys1))
)

(declare-rule re-star-union-drop-emp ((x1 RegLan :list) (y1 RegLan :list))
  :args (x1 y1)
  :conclusion (= (re.* (re.union x1 (str.to_re "") y1)) (re.* (re.union x1 y1)))
)

(declare-rule re-inter-cstring ((xs1 RegLan :list) (ys1 RegLan :list) (s1 String))
  :premises ((= (str.in_re s1 (re.inter xs1 ys1)) true))
  :args (xs1 ys1 s1)
  :conclusion (= (re.inter xs1 (str.to_re s1) ys1) (str.to_re s1))
)
(declare-rule re-inter-cstring-neg ((xs1 RegLan :list) (ys1 RegLan :list) (s1 String))
  :premises ((= (str.in_re s1 (re.inter xs1 ys1)) false))
  :args (xs1 ys1 s1)
  :conclusion (= (re.inter xs1 (str.to_re s1) ys1) re.none)
)
(declare-rule str-in-re-union-elim ((s1 String) (r1 RegLan) (r2 RegLan) (rs1 RegLan :list))
  :args (s1 r1 r2 rs1)
  :conclusion (= (str.in_re s1 (re.union r1 r2 rs1)) (or (str.in_re s1 r1) (str.in_re s1 (re.union r2 rs1))))
)
(declare-rule str-in-re-inter-elim ((s1 String) (r1 RegLan) (r2 RegLan) (rs1 RegLan :list))
  :args (s1 r1 r2 rs1)
  :conclusion (= (str.in_re s1 (re.inter r1 r2 rs1)) (and (str.in_re s1 r1) (str.in_re s1 (re.inter r2 rs1))))
)
