section \<open>Introduction\<close>

text\<open>
IsaRARE is a plugin for Isabelle that transforms rewrite rules in the RARE language into Isabelle
lemmas. It serves two main purposes:

\begin{enumerate}
\item Verification:
 Proving a lemma generated by IsaRARE indicates that the corresponding rule is sound.

\item Reconstruction:
 If rule is used in a proof certificate by an external solver, the generated lemmas can be used by
 the smt method during the reconstruction of that proof inside of Isabelle. 
\end{enumerate}

\<close>

section \<open>Set-up and Quick Usage\<close>

text\<open>
IsaRARE itself does not require any prerequisites but to execute the bit-vector examples in the
Tests/ folder a copy of Finite Machine Word Library from the Archive of Formal Proofs (AFP) is
needed \cite{WordLibAFP}. We have tested our tool with the version of the AFP from October 16, 2023.

IsaRARE can be used simply by importing IsaRARE.thy. To support Words use IsaRARE_Word. This is
merely a convenience solution since loading the Word library can take a while.
\<close>

theory IsaRARE
  imports HOL.SMT_CVC "HOL.Real" "HOL-Library.Smtlib_String" (*HOL.SMT_CVC_Word *) HOL.SMT_CVC_Extension Word_Lib.Reversed_Bit_Lists
  keywords "parse_rare_file" "parse_rare" "print_IsaRARE_options" :: diag
begin

text\<open>
The two keywords the theory provides are used as follows:\\

\begin{enumerate}
\item To parse a single RARE rule use:

@{command "parse_rare"} <input rare rule as string> 

Example usage:

@{command "parse_rare"} "(define-rule bool-eq-true ((t Bool)) (= t true) t)"\\

\item To parse a RARE file:

@{command "parse_rare_file"} <input rare file, theory imports, new theory name>

Example usage

@{command "parse_rare_file"} "/IsaRARE/Tests/example\_rewrites" "Parent\_Theory" "Example\_Rewrites"

\end{enumerate}

More information can be found in Section \ref{sec:functionality}.
\<close>



section \<open>The RARE language\label{sec:rare}\<close>

text\<open>
\input{RARE.tex}
\<close>

section \<open>Components\<close>

text \<open>
All components of IsaRARE can be found in src/. In the following, we briefly summarize the function
of each component on a high level. Additional information can be found as source code comments in
the respective file.
\<close>

ML_file \<open>src/isarare_config.ML\<close>

text \<open>
This file provides diagnostics and options for IsaRARE. The options and their usage are described
in Section \ref{sec:options}
\<close>

        
ML_file \<open>src/abstract_type_parser.ML\<close>

text \<open>
This file contains parser functionality for the extensions to SMT-LIB RARE offers. Mostly,
this concerns parsing approximate types (see Section \ref{sec:rare}). 
\<close>
ML_file \<open>src/rewrite_rule_ast.ML\<close>
ML_file \<open>src/parser_utils.ML\<close>
ML_file \<open>src/alf_ast.ML\<close>
ML_file \<open>src/alf_lexer.ML\<close>
ML_file \<open>src/alf_parser.ML\<close>
ML_file \<open>src/parse_rare.ML\<close>

text \<open>
This file provides functionality to parse a RARE rule into a AST. This datatype is called
rewrite_tree and is defined in this file.
\<close>
 
ML_file \<open>src/rare_impl_assms.ML\<close>

text \<open>
This file provides enables the addition of assumptions to the AST whenever Isabelle's
definition of an operator is too general for SMT-LIB.
\<close>

ML_file \<open>src/rare_lists.ML\<close>

text \<open>
This file provides enables the RARE extension of using variables annotated as :list.
\<close>

ML_file \<open>src/process_rare.ML\<close>

text \<open>
This file transforms the AST into a Isabelle term.
\<close>

ML_file \<open>src/write_theory.ML\<close>


text \<open>
In write_rewrite_as_lemma.ML the ASTs are translated into Isabelle terms and printed as lemmas. The
suggested proof is also generated here.
\<close>


section \<open>Functionality\label{sec:functionality}\<close>

text \<open>

To print the current status of all options use, @{command print_IsaRARE_options}.

Example output:

@{verbatim
"The options currently set for IsaRARE are:
home directory set to: 
verbose: false
debug: false
rule format RARE
implicit assumption generation: true
lists are treated as variables: false
the proof strategy is set to: Full
the proof theory strategy is set to: All
lemmas are in the right form to use them for reconstruction (makes them a bit harder to read): false"
}

\<close>

ML \<open>

fun print_rewrite (t:Toplevel.transition) :  Toplevel.transition =
  Toplevel.keep (fn toplevel => (fn state =>
   Print_Mode.with_modes [] (fn () => writeln (IsaRARE_Config.print_options state)) ())
   (Toplevel.context_of toplevel)) t

val _ =
  Outer_Syntax.command \<^command_keyword>\<open>print_IsaRARE_options\<close>
  "outputs all options currently set for IsaRARE"
  (Scan.succeed print_rewrite)
\<close>  

text \<open>

The command  @{command parse_rare} expects a rewrite as a single string. It can contain line
breaks or commands. It should only contain a single rewrite rule though. To transform more than one
line please use command  @{command parse_rare_file} (see below).

\<close>

ML \<open>
 val _ =
   Outer_Syntax.local_theory \<^command_keyword>\<open>parse_rare\<close>
   "parse a single rule in rare format (provided as a string) and output lemma"
  (Parse.string
  >> (fn (rule_str) => fn lthy =>
  let
    val ctxt = Local_Theory.target_of lthy

    (* Calculate result *)
    val parsed_lines = [rule_str] |> Parse_RARE.lex_rewrites ctxt |> Parse_RARE.parse_rewrites ctxt
    val _ = IsaRARE_Config.verbose_msg ctxt (K ("... done parsing rewrites"))
    val processed_smtlibTerm = parsed_lines |> map (Process_RARE.process_rule ctxt)
    val _ = IsaRARE_Config.verbose_msg ctxt (K ("... done processing rewrites"))
    val result = processed_smtlibTerm |> map (Write_Theory.write_lemma ctxt 1) |> String.concat
    val _ = Print_Mode.with_modes [] (fn () => writeln result)
    val _ = IsaRARE_Config.verbose_msg ctxt (K ("... done writing rewrites!"))

  in lthy end))
\<close>

text \<open>

For @{command parse_rare_file} there are no restrictions on import theories or target theory. In
the future we might use the imported theories internally (to suggest proofs). However, right now
we don't and it is just useful if you reload RARE theories often (e.g., you have the proofs in a
different file and use our option such that they are always used, see \ref{sec:options}). 
In that case you want to add the name of that theory so when you reload the theory from the RARE
file all proofs automatically go though again.

Either set @{verbatim "IsaRARE_HOME"} or use absolute paths. Otherwise, IsaRARE will not be able
to find your files. While we can get the path IsaRARE is started from we cannot get where it is
saved at currently.
\<close>

ML \<open>

val _ =  Outer_Syntax.local_theory \<^command_keyword>\<open>parse_rare_file\<close> ("parse file in rare format" ^
 "and output lemmas. <rare_file, import theories, target_theory>")
  (((Parse.string -- Parse.string)  -- Parse.string)
  >> (fn ((file_name,theory_imports),theory_name) => fn lthy =>
  let
    (*Built new path*)
    val ctxt = Local_Theory.target_of lthy
    val home = 
      if file_name |> Path.explode |> Path.expand |> Path.is_absolute 
      then ""
      else Config.get ctxt IsaRARE_Config.IsaRAREHome
    val file_path = Path.explode (home ^ file_name)
    val new_theory_name = theory_name ^ ".thy"
    val res_path = Path.append (Path.dir file_path) (Path.basic new_theory_name)
    val _ = IsaRARE_Config.verbose_msg ctxt
       (K ("Transforming rewrites from file: " ^ (res_path |> Path.implode) ^
           " into theory " ^ new_theory_name ^ " saved at " ^ (res_path |> Path.implode)))

    (*Calculate result*)
    val lines = Bytes.split_lines (Bytes.read file_path)
    val parsed_lines = lines |> Parse_RARE.lex_rewrites ctxt |> Parse_RARE.parse_rewrites ctxt
                        |> map (Process_RARE.process_rule ctxt)
    val _ = IsaRARE_Config.verbose_msg ctxt (K ("... done parsing rewrites"))
    val result = parsed_lines |> Write_Theory.write_thy ctxt theory_name theory_imports
    val _ = IsaRARE_Config.verbose_msg ctxt (K ("... done processing rewrites"))

     val _ = (Output.writeln result)
          val _ =
           Bytes.write
            res_path (Bytes.string result)
     val _ = IsaRARE_Config.verbose_msg ctxt (K ("... done writing rewrites!"))
 in  lthy
 end))
\<close>

declare[[IsaRARE_debug=false]]


(*parse_rare_file "~/Downloads/int2.smt2" "HOL.Real" "TestKey2"*)


section \<open>Examples\label{sec:examples}\<close>

text \<open>
 To run these change @{verbatim IsaRARE_HOME} below. Then, take them out of the comment. All
 examples in this file are without bit-vectors. For bit-vector examples look in
 \path{IsaRARE_Word.thy}.

 \path{level0_rewrites} contains examples without approximate types and without lists.
 \path{level2a_rewrites} contains examples with approximate types and without lists.
 \path{level2b_rewrites} contains examples without approximate types and with lists.
 \path{level2_rewrites} contains examples with approximate types and with lists.

 \path{level3_rewrites} contains examples with complex types (such as arrays and sets)
  but without implicit assumptions

\<close>

(*<*)
declare[[IsaRARE_HOME = "/home/mallku/carcara/Trabajo/Rare/IsaRARE/"]]

declare[[IsaRARE_debug]]
declare[[ML_print_depth=100]]
declare[[IsaRARE_seperateLemmasForTypes = true]]

(*>*)


parse_rare_file "Tests/level0_rewrites" "HOL.Real" "Level0_Rewrites"
parse_rare_file "Tests/level2a_rewrites" "HOL.Real" "Level2a_Rewrites"
parse_rare_file "Tests/level2b_rewrites" "HOL.Real" "Level2b_Rewrites"
parse_rare_file "Tests/level2_rewrites" "HOL.Real" "Level2_Rewrites"
parse_rare_file "Tests/level3a_rewrites" "HOL.Real" "Level3a_Rewrites"




parse_rare_file "Tests/Andy/arith_rewrites" "HOL.Real" "Arith_Rewrites"
parse_rare_file "Tests/Andy/boolean_rewrites" "HOL.Real" "Bool_Rewrites"

parse_rare_file "Tests/Andy/boolean_rewrites" "HOL.Real" "Bool_Rewrites"

parse_rare_file "Tests/Jibiana/no_lists_no_re.txt" "" "Jibiana_String_Rewrites"



parse_rare_file "Tests/Jibiana/lists.txt" "" "Jibiana_String_Rewrites_Lists"
parse_rare_file "Tests/Jibiana/re.txt" "" "Jibiana_String_Rewrites_Re"




parse_rare_file "Tests/Andy/boolean_rewrites" "HOL.Real" "New_String"


parse_rare_file "Tests/Andy/arith_rewrites" "HOL.Real" "New_String"


thm cvc_string_rewrite_defs
section \<open>Options\label{sec:options}\<close>

subsection \<open>General\<close>

text\<open>
@{attribute "IsaRARE_HOME"}<file\_path> can be used to change IsaRARE's home directory (which is the
location this file resides in by default). This is used to provide a relative path to the Tests
directory within Isabelle.
\<close>

subsection \<open>Traces and Debugging\<close>

text\<open>
To control the amount of information IsaRARE prints set @{attribute "IsaRARE_verbose"} to
<true|\textbf{false}>:
\<close>

  declare[[IsaRARE_verbose = true]] (*Get additional information*)

text\<open>
For debugging information set @{attribute "IsaRARE_verbose"} to <true|\textbf{false}>.
\<close>

  declare[[IsaRARE_debug = true]] (*Get debugging information*)

subsection \<open>Components\<close>

text\<open>
As explained in Section \ref{sec:functionality} there are discrepancies between some
SMT-LIB functions and their closest counterpart commonly used in some Isabelle library.
IsaRARE automatically adds assumption to lemmas if the Isabelle definition has to be restricted
because the SMT-LIB definition is undefined in some cases.

This information can make a lemma quite convoluted. The process can can be turned off with the option
@{attribute "IsaRARE_implAssump"} = \textbf{true}|false>. This can be useful to get an overview.

WARNING: Turning this option off might create a lemma that is false or far harder to prove than the
rewrite! Especially for rules containing bit-vectors IsaRARE might not be able to infer types
correctly from gradual types. We recommend using the proof strategy Minimum instead to simplify
assumptions. 
\<close>

declare[[IsaRARE_implAssump = true]] (*Turn implicit assumption generation on or off (Warning this is an expert option: Lemmas might not be provable without the assumptions) *)

declare[[IsaRARE_listsAsVar = false]] (*When turned on list parameters are parsed as if they were variables (Warning this is an expert option: Lemmas might be proven but corresponding RARE rule is not correct) *)


subsection \<open>Proofs\<close>

text\<open>
IsaRARE can generate differently elaborate proofs. While many lemmas can be proven fully
automatically this might fail for others. 

Proof suggestions can be completely turned off by setting @{attribute IsaRARE_proofStrategy} to
"None". This means however that some lemmas will contain IsaRARE specific definitions.

If you decide to use the suggested proof sketch you have to understand the two dimensions at
play here:

1. Reliability. You might plan to re-run IsaRARE on your rewrite database frequently. Any rules that
have not changed since the last run should still have a valid proof without any manual interaction.
For you the option Reliable is the best. This option will produce a proof sketch that only 
removes any custom IsaRARE definition from the lemma. Then, it will call a second lemma with the
same name (e.g., rewrite_double_neg) as the current lemma but with a  \_lemma added
to its name (i.e., rewrite_double_neg_lemma).
You can now copy the proof state at that point and make such a lemma. Then, you prove it in another
theory file that you add to the @{command parse_rare_file} as a parent theory.

2. Automation. You want to get all the help you can get to prove a lemma. The option Full with some
of the theory specific options explained below will be the best option for you. Sometimes it will
be too eager and solve the goal before the proof has finished. You will have to manually clean up
the file in that case. Often however, no user provided proof might be necessary at all.

There is a bit of a trade-off between these two goals. In the first case you need to provide a
lemma for every lemma even if it could be automatically proven just to avoid the case of any proof
failing. In the second case whenever you re-run IsaRARE one of your proofs might break. Usually,
it is a good idea to use Full the first time you use IsaRARE on a database and then copy the proofs
and use Reliable for regression tests. 

The option Minimum tries to find a balance between both approaches; it applies some heuristics to
decide whether a helper lemma is necessary or not.

IsaRARE_proofStrategy = <None | Minimum | Full | TACAS_Autoprove>
\<close>

declare[[IsaRARE_proofStrategy = "Minimum"]] (*Turn on specific strategies for proof printed, e.g. strings*)
declare[[ML_print_depth=10000]]

section \<open>Usage\label{sec:use}\<close>



section \<open>Test\<close>

parse_rare_file "Tests/mixed_rewrites" "" "Mixed_Rewrites"

subsection \<open>Regression Tests\<close>

text \<open>
IsaRARE contains a number of regression tests with RARE rules from various theories that are used
by the SMT solver cvc5. They can be found in Tests/Regression/.

\begin{center}
\begin{tabular}{ c | c | c }
 theory & rare file name & Isabelle theory name \\
 \hline
 EUF & euf\_rewrites & EUF\_Rewrites.thy \\
 Arithmetic & arith\_rewrites & Arith\_Rewrites.thy \\
 Sets & set\_rewrites & Set\_Rewrites.thy \\
 Arrays & array\_rewrites & Array\_Rewrites.thy \\
 Strings & string\_rewrites & String\_Rewrites.thy \\
 Bit-vectors & bv\_rewrites & Bitvector\_Rewrites.thy \\
             & bv\_rewrites\_proven & Bitvector\_Rewrites\_Proven.thy
\end{tabular}
\end{center}

For all theories except bit-vectors we were able to prove all lemmas corresponding to their rewrite
rules. For bit-vectors we therefore include two files; One with all the rewrite rules cvc5 uses
(bv\_rewrites) and one with the subset of these that we can prove (bv\_rewrites\_proven). The
corresponding Isabelle/HOL theories that contain the lemmas that IsaRARE generated are in the same
directory.

To run IsaRARE on all RARE files in Tests/ on the command line:

  isabelle build -d <path\_to\_afp>/thys/ -d. IsaRARE-Tests

To build the resulting theories (check that the proofs we provide work) run:

  isabelle build -d <path\_to\_afp>/thys/ -d. IsaRARE-Results

This checks all files except the bit-vector rewrites that we have not proven yet.

To use the graphical user interface open Tests/IsaRARE\_Tests.thy. 
\<close>

print_IsaRARE_options

section \<open>Limitations\<close>

text \<open>
If you are parsing a name defined in another theory it is going to be from that theory even if you
don't intend to This should not matter to IsaRARE

Real constants currently have to be written with a decimal point 0.0

No two rules with the same name in the same file currently (we can change that if there is need) 
\<close>

(*
Note: IsaRARE can currently not deal with line breaks in rewrite rules
*)

declare[[IsaRARE_verbose = true,IsaRARE_debug]]
parse_rare_file "Tests/new_bv_rewrites" "HOL.Real" "New_BV_Rewrites"


end
